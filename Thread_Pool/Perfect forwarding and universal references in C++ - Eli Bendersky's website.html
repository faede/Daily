<!DOCTYPE html>
<!-- saved from url=(0084)https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/ -->
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:og="http://ogp.me/ns#" xmlns:fb="https://www.facebook.com/2008/fbml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Perfect forwarding and universal references in C++ - Eli Bendersky's website</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="https://eli.thegreenplace.net/favicon.ico" rel="icon">

    <!-- Bootstrap -->
        <link rel="stylesheet" href="./Perfect forwarding and universal references in C++ - Eli Bendersky&#39;s website_files/bootstrap.min.css" type="text/css">
    <link href="./Perfect forwarding and universal references in C++ - Eli Bendersky&#39;s website_files/font-awesome.min.css" rel="stylesheet">

    <link href="./Perfect forwarding and universal references in C++ - Eli Bendersky&#39;s website_files/vs.css" rel="stylesheet">
    <link rel="stylesheet" href="./Perfect forwarding and universal references in C++ - Eli Bendersky&#39;s website_files/style.css" type="text/css">

        <link href="https://eli.thegreenplace.net/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Eli Bendersky&#39;s website ATOM Feed">

<script charset="utf-8" src="chrome-extension://jgphnjokjhjlcnnajmfjlacjnjkhleah/js/btype.js"></script><script type="text/javascript" charset="utf-8" src="chrome-extension://jgphnjokjhjlcnnajmfjlacjnjkhleah/js/chrome.js"></script></head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://eli.thegreenplace.net/" class="navbar-brand">
                <img src="./Perfect forwarding and universal references in C++ - Eli Bendersky&#39;s website_files/logosmall.png" width="32">
Eli Bendersky's website            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="https://eli.thegreenplace.net/pages/about">
                        <i class="fa fa-question"></i>
                        <span class="icon-label">About</span>
                    </a>
                </li>
                <li>
                    <a href="https://eli.thegreenplace.net/archives/all">
                        <i class="fa fa-th-list"></i>
                        <span class="icon-label">Archives</span>
                    </a>
                </li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->

<div class="container">
    <div class="row">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/" rel="bookmark" title="Permalink to Perfect forwarding and universal references in C++">
                        Perfect forwarding and universal references in C++
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="published">
        <i class="fa fa-calendar"></i>
        <time> November 03, 2014 at 05:52</time>
    </span>
<span class="label label-default">Tags</span>
    <a href="https://eli.thegreenplace.net/tag/c-c">C &amp; C++</a>
        ,
    <a href="https://eli.thegreenplace.net/tag/articles">Articles</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>One of the new features in C++11 aimed at increased code efficiency is the
<tt class="docutils literal">emplace</tt> family of methods in containers.  <tt class="docutils literal"><span class="pre">std::vector</span></tt>, for example, has
an <tt class="docutils literal">emplace_back</tt> method to parallel <tt class="docutils literal">push_back</tt>, and <tt class="docutils literal">emplace</tt> to
parallel <tt class="docutils literal">insert</tt>.</p>
<p>Here's a short demonstration of the benefits these new methods bring:</p>
<div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyKlass</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">MyKlass</span><span class="p">(</span><span class="kt">int</span> <span class="n">ii_</span><span class="p">,</span> <span class="kt">float</span> <span class="n">ff_</span><span class="p">)</span> <span class="p">{...}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="p">{...}</span>
<span class="p">};</span>

<span class="n">some</span> <span class="n">function</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MyKlass</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>

  <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">MyKlass</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">3.14f</span><span class="p">));</span>
  <span class="n">v</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">3.14f</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>If you trace the execution of the constructors and destructor of <tt class="docutils literal">MyKlass</tt>,
you'll see something like the following for the <tt class="docutils literal">push_back</tt> call:</p>
<ul class="simple">
<li>Constructor for a temporary <tt class="docutils literal">MyKlass</tt> object</li>
<li>Move constructor (if one was defined for <tt class="docutils literal">MyKlass</tt>, otherwise a copy
constructor) for the object actually allocated inside the vector</li>
<li>Destructor for the temporary</li>
</ul>
<p>This is quite a lot of work. Much of it isn't required though, since the object
passed to <tt class="docutils literal">push_back</tt> is obviously an rvalue that ceases to exist after the
statement is completed; there's no reason to create and destroy a temporary -
why not just construct the object inside the vector directly?</p>
<p>This is exactly what <tt class="docutils literal">emplace_back</tt> does. For the <tt class="docutils literal">v.emplace_back(2, 3.14f)</tt>
call above, all you see is a single constructor invocation. This is the object
constructed <em>inside</em> the vector. No temporaries are needed.</p>
<p><tt class="docutils literal">emplace_back</tt> accomplishes this by invoking the constructor of <tt class="docutils literal">MyKlass</tt> on
its own and forwarding its arguments to the constructor. This feat is made
possible by two new features in C++11:
<a class="reference external" href="http://eli.thegreenplace.net/2014/variadic-templates-in-c/">variadic templates</a>
and perfect forwarding. In this article I want to explain how perfect forwarding
works and how to use it.</p>
<div class="section" id="the-perfect-forwarding-problem">
<h2>The perfect forwarding problem</h2>
<p>Let <tt class="docutils literal">func(E1, E2, <span class="pre">...,</span> En)</tt> be an arbitrary function call with generic
parameters <tt class="docutils literal">E1, E2, <span class="pre">...,</span> En</tt>. We'd like to write a function <tt class="docutils literal">wrapper</tt> such
that <tt class="docutils literal">wrapper(E1, E2, <span class="pre">...,</span> En)</tt> is equivalent to <tt class="docutils literal">func(E1, E2, <span class="pre">...,</span> En)</tt>. In
other words, we'd like to define a function with generic parameters that
forwards its parameters <em>perfectly</em> to some other function.</p>
<p>To have something concrete to relate this definition to, think of the
<tt class="docutils literal">emplace_back</tt> method discussed above. <tt class="docutils literal"><span class="pre">vector&lt;T&gt;::emplace_back</span></tt> forwards
its parameters to a constructor of <tt class="docutils literal">T</tt>, without actually knowing how <tt class="docutils literal">T</tt>
looks like.</p>
<p>Next, I'm going to show a few examples of how we might approach this in pre-11
C++. For simplicity's sake, I'll put variadic templates aside; let's assume all
we need to forward is two arguments.</p>
<p>The first approach that comes to mind is:</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">T1</span> <span class="n">e1</span><span class="p">,</span> <span class="n">T2</span> <span class="n">e2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">func</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>This will obviously not work if <tt class="docutils literal">func</tt> accepts its parameters by reference,
since <tt class="docutils literal">wrapper</tt> introduces a by-value passing step. If <tt class="docutils literal">func</tt> modifies its
by-reference parameter, it won't be visible in the caller of <tt class="docutils literal">wrapper</tt> (only
the copy created by <tt class="docutils literal">wrapper</tt> itself will be affected).</p>
<p>OK, then, we can make <tt class="docutils literal">wrapper</tt> accept its parameters by reference. This
should not interfere with <tt class="docutils literal">func</tt>'s taking parameters by value, because the
call to <tt class="docutils literal">func</tt> within <tt class="docutils literal">wrapper</tt> will create the required copy.</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">T1</span><span class="o">&amp;</span> <span class="n">e1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&amp;</span> <span class="n">e2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">func</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>This has another problem, though. Rvalues cannot be bound to function parameters
that are references, so the following completely reasonable calls will now fail:</p>
<div class="highlight"><pre><span></span><span class="n">wrapper</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="mf">3.14f</span><span class="p">);</span>                  <span class="c1">// error: invalid initialization of</span>
                                     <span class="c1">//        non-const reference from</span>
                                     <span class="c1">//        an rvalue</span>

<span class="n">wrapper</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">foo_returning_float</span><span class="p">());</span>   <span class="c1">// same error</span>
</pre></div>
<p>And no, making those reference parameters <tt class="docutils literal">const</tt> won't cut it either, because
<tt class="docutils literal">func</tt> may legitimately want to accept non-<tt class="docutils literal">const</tt> reference parameters.</p>
<p>What remains is the brute-force approach taken by some libraries: define
overloads for both <tt class="docutils literal">const</tt> and non-<tt class="docutils literal">const</tt> references:</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">T1</span><span class="o">&amp;</span> <span class="n">e1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&amp;</span> <span class="n">e2</span><span class="p">)</span>                <span class="p">{</span> <span class="n">func</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">);</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">wrapper</span><span class="p">(</span><span class="k">const</span> <span class="n">T1</span><span class="o">&amp;</span> <span class="n">e1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&amp;</span> <span class="n">e2</span><span class="p">)</span>          <span class="p">{</span> <span class="n">func</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">);</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">T1</span><span class="o">&amp;</span> <span class="n">e1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T2</span><span class="o">&amp;</span> <span class="n">e2</span><span class="p">)</span>          <span class="p">{</span> <span class="n">func</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">);</span> <span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">wrapper</span><span class="p">(</span><span class="k">const</span> <span class="n">T1</span><span class="o">&amp;</span> <span class="n">e1</span><span class="p">,</span> <span class="k">const</span> <span class="n">T2</span><span class="o">&amp;</span> <span class="n">e2</span><span class="p">)</span>    <span class="p">{</span> <span class="n">func</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">);</span> <span class="p">}</span>
</pre></div>
<p>Exponential explosion. You can imagine how much fun this becomes when we want to
cover some reasonable amount of function parameters. To make things worse, C++11
adds rvalue references to the mix (which we'd also want to forward correctly),
and this clearly isn't a scalable solution.</p>
</div>
<div class="section" id="reference-collapsing-and-special-type-deduction-for-rvalues">
<h2>Reference collapsing and special type deduction for rvalues</h2>
<p>To explain how C++11 solves the perfect forwarding problem, we have to first
understand two new rules that were added to the language.</p>
<p>Reference collapsing is the easier one to explain, so let's start with it.
Taking a reference to a reference is illegal in C++. However, it can sometimes
arise in the context of templates and type deduction:</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">baz</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">T</span><span class="o">&amp;</span> <span class="n">k</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
<p>What happens if we call this function as follows:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="n">baz</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">ii</span><span class="p">);</span>
</pre></div>
<p>In the template instantiation, <tt class="docutils literal">T</tt> is explicitly set to <tt class="docutils literal">int&amp;</tt>. So what is
the type of <tt class="docutils literal">k</tt> inside? What the compiler "sees" is <tt class="docutils literal">int&amp; &amp;</tt> - while this
isn't something the user is allowed to write in code, the compiler simply infers
a single reference from this. In fact, prior to C++11 this wasn't standardized,
but many compilers accepted such code anyway because these cases occasionally
arise in template metaprogramming. With the addition of <a class="reference external" href="http://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c">rvalue references</a>
in C++11, it became important to define what happens when various reference
types augment (e.g. what does <tt class="docutils literal">int&amp;&amp; &amp;</tt> mean?).</p>
<p>The result is the <em>reference collapsing</em> rule. The rule is very simple. <tt class="docutils literal">&amp;</tt>
always wins. So <tt class="docutils literal">&amp; &amp;</tt> is <tt class="docutils literal">&amp;</tt>, and so are <tt class="docutils literal">&amp;&amp; &amp;</tt> and <tt class="docutils literal">&amp; &amp;&amp;</tt>. The only
case where <tt class="docutils literal">&amp;&amp;</tt> emerges from collapsing is <tt class="docutils literal">&amp;&amp; &amp;&amp;</tt>. You can think of it as a
logical-OR, with <tt class="docutils literal">&amp;</tt> being 1 and <tt class="docutils literal">&amp;&amp;</tt> being 0.</p>
<p>The other addition to C++11 relevant to this article is special type deduction
rules for rvalue references in some cases <a class="footnote-reference" href="https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/#id5" id="id1">[1]</a>. Given a function template like:</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
<p>Don't let <tt class="docutils literal">T&amp;&amp;</tt> fool you here - <tt class="docutils literal">t</tt> is not an rvalue reference <a class="footnote-reference" href="https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/#id6" id="id2">[2]</a>. When it
appears in a type-deducing context, <tt class="docutils literal">T&amp;&amp;</tt> acquires a special meaning. When
<tt class="docutils literal">func</tt> is instantiated, <tt class="docutils literal">T</tt> depends on whether the argument passed to
<tt class="docutils literal">func</tt> is an lvalue or an rvalue. If it's an lvalue of type <tt class="docutils literal">U</tt>, <tt class="docutils literal">T</tt> is
deduced to <tt class="docutils literal">U&amp;</tt>. If it's an rvalue, <tt class="docutils literal">T</tt> is deduced to <tt class="docutils literal">U</tt>:</p>
<div class="highlight"><pre><span></span><span class="n">func</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>            <span class="c1">// 4 is an rvalue: T deduced to int</span>

<span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="n">func</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>            <span class="c1">// d is an lvalue; T deduced to double&amp;</span>

<span class="kt">float</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{...}</span>
<span class="n">func</span><span class="p">(</span><span class="n">f</span><span class="p">());</span>          <span class="c1">// f() is an rvalue; T deduced to float</span>

<span class="kt">int</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">func</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>          <span class="c1">// i is an lvalue; T deduced to int&amp;</span>
<span class="p">}</span>
</pre></div>
<p>This rule may seem unusual and strange. That's because it is. However, it starts
making sense when we realize it was designed to solve the perfect forwarding
problem.</p>
</div>
<div class="section" id="solving-perfect-forwarding-with-std-forward">
<h2>Solving perfect forwarding with std::forward</h2>
<p>Let's get back to our original <tt class="docutils literal">wrapper</tt> template. Here's how it should be
written in C++11:</p>
<div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="n">T2</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">wrapper</span><span class="p">(</span><span class="n">T1</span><span class="o">&amp;&amp;</span> <span class="n">e1</span><span class="p">,</span> <span class="n">T2</span><span class="o">&amp;&amp;</span> <span class="n">e2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">func</span><span class="p">(</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e1</span><span class="p">),</span> <span class="n">forward</span><span class="o">&lt;</span><span class="n">T2</span><span class="o">&gt;</span><span class="p">(</span><span class="n">e2</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
<p>And this is <tt class="docutils literal">forward</tt>:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="k">typename</span> <span class="n">std</span><span class="o">::</span><span class="n">remove_reference</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">type</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Let's say we call:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="n">ii</span> <span class="p">...;</span>
<span class="kt">float</span> <span class="n">ff</span> <span class="p">...;</span>
<span class="n">wrapper</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">ff</span><span class="p">);</span>
</pre></div>
<p>Examining the first argument (since the second is handled similarly): <tt class="docutils literal">ii</tt>
is an lvalue, so <tt class="docutils literal">T1</tt> is deduced to <tt class="docutils literal">int&amp;</tt> following the special deduction
rules. We get the call <tt class="docutils literal"><span class="pre">func(forward&lt;int&amp;&gt;(e1),</span> <span class="pre">...)</span></tt>. Therefore, <tt class="docutils literal">forward</tt>
is instantiated with <tt class="docutils literal">int&amp;</tt> and we get this version of it:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">&amp;</span> <span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;</span> <span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>Now it's time to apply the reference collapsing rule:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>In other words, the argument is passed on by reference to <tt class="docutils literal">func</tt>, as needed
for lvalues.</p>
<p>The other case to handle is:</p>
<div class="highlight"><pre><span></span><span class="n">wrapper</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="mf">3.14f</span><span class="p">);</span>
</pre></div>
<p>Here the arguments are rvalues, so <tt class="docutils literal">T1</tt> is deduced to <tt class="docutils literal">int</tt>. We get the
call <tt class="docutils literal"><span class="pre">func(forward&lt;int&gt;(e1),</span> <span class="pre">...)</span></tt>. Therefore, <tt class="docutils literal">forward</tt> is instantiated
with <tt class="docutils literal">int</tt> and we get this version of it <a class="footnote-reference" href="https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/#id7" id="id3">[3]</a>:</p>
<div class="highlight"><pre><span></span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">forward</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&amp;&amp;&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>One can see <tt class="docutils literal">forward</tt> as a pretty wrapper around <tt class="docutils literal"><span class="pre">static_cast&lt;T&amp;&amp;&gt;(t)</span></tt>
when <tt class="docutils literal">T</tt> can be deduced to either <tt class="docutils literal">U&amp;</tt> or <tt class="docutils literal">U&amp;&amp;</tt>, depending on the kind of
argument to the wrapper (lvalue or rvalue). Now we get <tt class="docutils literal">wrapper</tt> as a single
template that handles all kinds of forwarding cleanly.</p>
<p>The <tt class="docutils literal">forward</tt> template exists in C++11, in the <tt class="docutils literal">&lt;utility&gt;</tt> header, as
<tt class="docutils literal"><span class="pre">std::forward</span></tt>.</p>
<p>Another thing I want to mention is the use of <tt class="docutils literal"><span class="pre">std::remove_reference&lt;T&gt;</span></tt>. In
fact, it you think about it, <tt class="docutils literal">forward</tt> could do without it. Reference
collapsing does the job already, so <tt class="docutils literal"><span class="pre">std::remove_reference&lt;T&gt;</span></tt> is superfluous.
It's there to turn the <tt class="docutils literal">T&amp; t</tt> into a non-deducing context (according to the
C++ standard, section 14.8.2.5), thus forcing us to explicitly specify the
template parameter when calling <tt class="docutils literal"><span class="pre">std::forward</span></tt>.</p>
</div>
<div class="section" id="universal-references">
<h2>Universal references</h2>
<p>In his talks, blog posts and book, Scott Myers gave the name "universal
references" to rvalues that appear in a type-deducing context. Whether this is a
useful mnemonic or not depends on the beholder; personally, when I first read
the relevant chapters of the new "Effective C++", I found myself seriously
confused on this topic. Only later, when I understood the underlying mechanisms
(reference collapsing and special deduction rules), the topic became somewhat
clearer.</p>
<p>The trap is that saying "universal references" <a class="footnote-reference" href="https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/#id8" id="id4">[4]</a> is surely more succinct and
nice than "rvalue references in a type deducing context", but once you want to
really understand some piece of code (rather than just cargo-culting
boilerplate), you'll find that avoiding the full definition is impossible.</p>
</div>
<div class="section" id="examples-of-using-perfect-forwarding">
<h2>Examples of using perfect forwarding</h2>
<p>Perfect forwarding is extremely useful, because it enables a kind of higher
order programming. <em>Higher order functions</em> are functions that may take other
functions as arguments or return them. Without perfect forwarding, higher order
functions are cumbersome because there is no convenient way to forward arguments
to wrapped functions. And by "functions" here I mean classes as well, whose
constructors are still functions.</p>
<p>In the beginning of the article I mentioned the <tt class="docutils literal">emplace_back</tt> method of
containers. Another good examples is <tt class="docutils literal">make_unique</tt>, which I described in the
<a class="reference external" href="http://eli.thegreenplace.net/2014/variadic-templates-in-c/">previous article</a>:</p>
<div class="highlight"><pre><span></span><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span><span class="p">...</span> <span class="n">Args</span><span class="o">&gt;</span>
<span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">make_unique</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">T</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...));</span>
<span class="p">}</span>
</pre></div>
<p>There, I pleaded to ignore the strange <tt class="docutils literal">&amp;&amp;</tt> syntax and focus on the variadic
template packs, but now there's no trouble fully understanding the code. It goes
without saying that perfect forwarding and variadic templates very often go hand
in hand, because we generally don't know how many arguments the
functions or constructors we pass around accept.</p>
<p>For a significantly more complex use of perfect forwarding, you may also want
to take a look at <tt class="docutils literal"><span class="pre">std::bind</span></tt>.</p>
</div>
<div class="section" id="links-to-resources">
<h2>Links to resources</h2>
<p>Here are some of the resources I found helpful while preparing this article:</p>
<ol class="arabic simple">
<li>The 4th edition of "The C++ Programming Language" by Bjarne Stroustrup</li>
<li>The new "Effective Modern C++" by Scott Myers has an extensive discussion of
"universal references". In fact, more than 1/5th of the book is dedicated to
the topic (gasp!).</li>
<li>Technical paper <a class="reference external" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2002/n1385.htm">n1385</a>:
"The forwarding problem: Arguments".</li>
<li>Thomas Becker's <a class="reference external" href="http://thbecker.net/articles/rvalue_references/section_01.html">C++ Rvalue references explained</a>
is extremely well-written and useful.</li>
</ol>
<hr class="docutils">
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/#id1">[1]</a></td><td>There rules apply in other situations, like <tt class="docutils literal">auto</tt> and <tt class="docutils literal">decltype</tt>.
Here I'm only presenting the template case.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/#id2">[2]</a></td><td>I think it's unfortunate that the C++ commitee didn't pick a different
syntax for this case and overloaded the meaning of <tt class="docutils literal">&amp;&amp;</tt> instead. I
realize it seems like a relatively uncommon use, for which it'd be a
shame to change the language syntax (a thing the commitee tries to avoid
as much as possible), but IMHO the situation is too confusing now. Even
Scott Myers admitted in a talk and some comments on his blog that after 3
years this material is still "sinking in". And Bjarne Stroustrup has a
mistake in the 4th edition of "The C++ Programming Language" when
describing <tt class="docutils literal"><span class="pre">std::forward</span></tt> - forgetting to explicitly provide a template
argument when calling it. This stuff is complex!</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/#id3">[3]</a></td><td>Note that in actual test code, the <tt class="docutils literal">int&amp;</tt> overload of <tt class="docutils literal">forward</tt>
seems to be selected for simple integer rvalues, rather than the
<tt class="docutils literal">int&amp;&amp;</tt> overload. This could be due to them being simple types always
passed by value. Let me know if you figure out why this is happening.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label"><col></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/#id4">[4]</a></td><td>"Forwarding references" is another name I've heard used elsewhere.</td></tr>
</tbody>
</table>
</div>

            </div>
            <!-- /.entry-content -->
<hr>
<div class="dotted-links">
<p class="align-center">
For comments, please send me
<a href="mailto:eliben@gmail.com"><i class="fa fa-envelope-o"></i> an email</a>.
</p>
</div>        </article>
    </section>

    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">
            © 2003-2022 Eli Bendersky
         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="https://eli.thegreenplace.net/2014/perfect-forwarding-and-universal-references-in-c/#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script async="" src="./Perfect forwarding and universal references in C++ - Eli Bendersky&#39;s website_files/analytics.js"></script><script src="./Perfect forwarding and universal references in C++ - Eli Bendersky&#39;s website_files/jquery-2.1.1.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="./Perfect forwarding and universal references in C++ - Eli Bendersky&#39;s website_files/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="./Perfect forwarding and universal references in C++ - Eli Bendersky&#39;s website_files/respond.min.js"></script>

<script type="text/javascript">

  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-54426790-1', 'auto');
  ga('send', 'pageview');

</script>

<div id="weava-permanent-marker" date="1643567444086"></div><div id="weava-ui-wrapper"><div class="weava-drop-area-wrapper"><div class="weava-drop-area"></div>
<div class="weava-drop-area-text">Drop here!</div>
</div><iframe id="weava-popover-iframe" scrolling="no" frameborder="0" src="./Perfect forwarding and universal references in C++ - Eli Bendersky&#39;s website_files/popover-index.html" style="height: 77px !important; top: 346.125px; left: 135.875px; display: none;"></iframe></div></body></html>