#  平摊分析

## 1.hash表需要多大？

越大越好(time)

尽可能小(space )

$\Theta $(n) for n items

Problem  :don't know n?

## Solution: dynamic tables

overflow => grow it

- 1.Reallocate  (molloc ot new) 2*n ,double it

- 2.move to new

- 3.free old table

Analytics 

Seq of insert ops 

Worst cost of 1 insert $\Theta$(n)

=>Worst cost of n inserts  = n* $\Theta$(n)=$\Theta$($n^{2}$)

Wrong :Worst cost of n inserts  = $\Theta$(n)

Let $c_i $ = i if i- is exaotct power of 2 ,  = 1 otherwise

i.        1. 2. 3  4 5 6 7. 8 9 10

size.  1. 2. 4. 4 8 8 8 8 16 16

c_i.    1. 2. 3. 1 5 1 1 1   9   1

​          1  1  1  1 1 1 1 1.  1.  1

​               1 2.     4             8

 = $\sum _{i = 1}^{n} =n + \sum_{j = 0}^{log(n-1)}2^{j}\\<=3n=\Theta(n)$

Thus ,average cost of n insert  = $\Theta (n)/n=\Theta(1)$

## Amortized analysisi

Analyze a seq of ops to shwo that ave cost per op is small, even though 1 op may be expensive 

no probability - ave perf in worst case

Types of amortized arguments 

- Aggregate (just -saw) 聚集分析

- Accounting  记账方法.         }
-  potential 势能分析              }.     更精确，为每个操作分配了特定的平摊代价(不能轻松分析时)

### Accounting method:

- Charage i -th op a 虚构的平摊代价 cost $\hat{c_i}$ ($1 pays for 1unit of work)

- 费用是支付给每个操作的，

- 剩余的钱将会存放在银行里，为了后续的操作

- bank balance not go neg，Must have $\sum c_i <= \sum\hat{c_i}$ ,真实代价小于等于平摊代价

Dynamic table 

Charge $\hat{c_i}$ = $3 for i-th insert

$1 for an immediate insert

$2 ,用于将表翻倍的存储费用

 When table double

$1 moves recent item

$1 moves old item

| 0    | 0    | 0    | 0    |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

再插入一个剩下$2

| 0    | 0    | 0    | 0    | 2    |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

再插入一个剩下$2

| 0    | 0    | 0    | 0    | 2    | 2    |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

再插入一个..

| 0    | 0    | 0    | 0    | 2    | 2    | 2    | 2    |
| ---- | ---- | ---- | :--- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

加倍后，正好$8

| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 2    |      |      |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 2    | 2    | 2    |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

这样总是够，银行总不负

所以$\hat{c_i}$ 平摊代价

$\sum c_i <= \sum \hat{c_i}$ 

​			<= 3n

i.        1. 2. 3  4 5 6 7. 8 9 10

size.  1. 2. 4. 4 8 8 8 8 16 16

c_i.    1. 2. 3. 1 5 1 1 1   9   1

​          1  1  1  1 1 1 1 1.  1.  1

​               1 2.     4             8

$\hat{c_i}$       2  3. 3 3  3. 3 3 3.  3. 3

Bnk.  1 2  2  4 2. 4 6 8.  2   4

第一个可以收3，也可以

并且尝试全是2，不够

删除时要注意反复

### Potential  method

"Bank account " viewed as potential 

energy of dynamic set



### Framework

- Start with data struct $D_0$

- Op i transforms $D_{i-1} => D_{i}$

- Cost of operate $c_i$

=>Define potential function

找到函数$\Phi  - \{ D_i \}->R$ 将数据结构映射到实数

$\Phi(D_0) = 0\quad and\quad \Phi(D_i) >=0\quad  \forall i$

(可能D_0不等于0，这只是一种)

定义平摊代价 $\hat{c_i}$   for $\Phi $  is

$\hat{c_i} = c_i + \Phi(D_i)-\Phi(D_{i-1})$

​				potential difference,$ \Delta \Phi_i$	

If $ \Delta \Phi_i > 0$ then $\hat{c_i}$ > c_i

stores work in data structure for later

说明收取的费用多余实际费用，多余的费用存进银行变为势能	

If $ \Delta \Phi_i < 0$ then $\hat{c_i} $> c_i

Structure delivers up work to help pay for op i

### Total amor cost of n ops is

$\sum_{i=1}^{n}\hat{c_i} = \sum_{i=1}^{n}( c_i + \Phi(D_i)-\Phi(D_{i-1}))\\ =\sum_{i=1}^{n}c_i+\Phi(D_n)-\Phi(D_0)\\ >=\sum_{i=1}^{n}c_i$

For  $\Phi(D_n)>=0,\Phi(D_0) = 0$

### Table doubling

Define $\Phi(D_i) = 2i-2^{\lceil log(i) \rceil}$ 

Assume    $2^{\lceil log(0) \rceil} = 0$

Note: $\Phi(D_0) = 0,\Phi(D_i) >= 0\quad \forall i,\lceil log(i) \rceil$<=log(i)+1

| 0    | 0    | 0    | 0    | 0    | 0    |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

$\Phi = 2*6-2^2=4$

Counting : 0 0 0 0 2 2

Amortizations  Cost of i -th insert

$\hat{c_i} = c_i + \Phi(D_i)-\Phi(D_{i-1})\\ =i\quad if \  i-1 \ is\ power\  of\ 2,\\ \quad1\quad otherwise\\ + (2i-2^{\lceil log(i) \rceil})-( 2(i-1)-2^{\lceil log(i-1) \rceil})\\ =i\quad if \  i-1 \ is\ power\  of\ 2,\\  \quad1\quad otherwise\\ +2-2^{\lceil log(i) \rceil}+2^{\lceil log(i-1) \rceil}$



Case 1, i -1 is exact power of 2

$\hat{c_i} = i +2-2(i-1)+(i-1)\\ =3$

Case 2,i -1 is not an exact power of 2

$\hat{c_i} = 1 +2\\ =3$ 

=>n inserts costs $\Theta(n)$ in the worst case

(bug：第一个其实是2)

$\hat{c_i}=1+2-1+0\\ =2$

## sum

- 平摊分析为数据结构的性能提供了一个简洁的抽象概念。

- 通常情况下每种都能用，每种都有某种情况是最简单或精确的。

- 不同的势能函数或不能的记账代价可能产生不同的上限