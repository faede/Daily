#  平摊分析、表的扩增、势能方法

## hash表需要多大？

越大越好(time)

尽可能小(space )

$\Theta $(n) for n items

Problem  :don't know n?

## Solution: dynamic tables

overflow => grow it

- 1.Reallocate  (molloc ot new) 2*n ,double it

- 2.move to new

- 3.free old table

Analytics 

Seq of insert ops 

Worst cost of 1 insert $\Theta$(n)

=>Worst cost of n inserts  = n* $\Theta$(n)=$\Theta$($n^{2}$)

Wrong :Worst cost of n inserts  = $\Theta$(n)

Let $c_i $ = i if i- is exaotct power of 2 ,  = 1 otherwise

i.        1. 2. 3  4 5 6 7. 8 9 10

size.  1. 2. 4. 4 8 8 8 8 16 16

c_i.    1. 2. 3. 1 5 1 1 1   9   1

​          1  1  1  1 1 1 1 1.  1.  1

​               1 2.     4             8

 = $\sum _{i = 1}^{n} =n + \sum_{j = 0}^{log(n-1)}2^{j}\\<=3n=\Theta(n)$

Thus ,average cost of n insert  = $\Theta (n)/n=\Theta(1)$

## Amortized analysis

Analyze a seq of ops to shwo that ave cost per op is small, even though 1 op may be expensive 

no probability - ave perf in worst case

Types of amortized arguments 

- Aggregate (just -saw) 聚集分析

- Accounting  记账方法.         }
-  potential 势能分析              }.     更精确，为每个操作分配了特定的平摊代价(不能轻松分析时)

### Accounting method

- Charage i -th op a 虚构的平摊代价 cost $\hat{c_i}$ ($1 pays for 1unit of work)

- 费用是支付给每个操作的，

- 剩余的钱将会存放在银行里，为了后续的操作

- bank balance not go neg，Must have $\sum c_i <= \sum\hat{c_i}$ ,真实代价小于等于平摊代价

Dynamic table 

Charge $\hat{c_i}$ = $3 for i-th insert

$1 for an immediate insert

$2 ,用于将表翻倍的存储费用

 When table double

$1 moves recent item

$1 moves old item

| 0    | 0    | 0    | 0    |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

再插入一个剩下$2

| 0    | 0    | 0    | 0    | 2    |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

再插入一个剩下$2

| 0    | 0    | 0    | 0    | 2    | 2    |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

再插入一个..

| 0    | 0    | 0    | 0    | 2    | 2    | 2    | 2    |
| ---- | ---- | ---- | :--- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

加倍后，正好$8

| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 2    |      |      |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 2    | 2    | 2    |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

这样总是够，银行总不负

所以$\hat{c_i}$ 平摊代价

$\sum c_i <= \sum \hat{c_i}$ 

​			<= 3n

i.        1. 2. 3  4 5 6 7. 8 9 10

size.  1. 2. 4. 4 8 8 8 8 16 16

c_i.    1. 2. 3. 1 5 1 1 1   9   1

​          1  1  1  1 1 1 1 1.  1.  1

​               1 2.     4             8

$\hat{c_i}$       2  3. 3 3  3. 3 3 3.  3. 3

Bnk.  1 2  2  4 2. 4 6 8.  2   4

第一个可以收3，也可以

并且尝试全是2，不够

删除时要注意反复

### Potential  method

"Bank account " viewed as potential 

energy of dynamic set



### Framework

- Start with data struct $D_0$

- Op i transforms $D_{i-1} => D_{i}$

- Cost of operate $c_i$

=>Define potential function

找到函数$\Phi  - \{ D_i \}->R$ 将数据结构映射到实数

$\Phi(D_0) = 0\quad and\quad \Phi(D_i) >=0\quad  \forall i$

(可能D_0不等于0，这只是一种)

定义平摊代价 $\hat{c_i}$   for $\Phi $  is

$\hat{c_i} = c_i + \Phi(D_i)-\Phi(D_{i-1})$

​				potential difference,$ \Delta \Phi_i$	

If $ \Delta \Phi_i > 0$ then $\hat{c_i}$ > c_i

stores work in data structure for later

说明收取的费用多余实际费用，多余的费用存进银行变为势能	

If $ \Delta \Phi_i < 0$ then $\hat{c_i} $> c_i

Structure delivers up work to help pay for op i

### Total amor cost of n ops is

$\sum_{i=1}^{n}\hat{c_i} = \sum_{i=1}^{n}( c_i + \Phi(D_i)-\Phi(D_{i-1}))\\ =\sum_{i=1}^{n}c_i+\Phi(D_n)-\Phi(D_0)\\ >=\sum_{i=1}^{n}c_i$

For  $\Phi(D_n)>=0,\Phi(D_0) = 0$

### Table doubling

Define $\Phi(D_i) = 2i-2^{\lceil log(i) \rceil}$ 

Assume    $2^{\lceil log(0) \rceil} = 0$

Note: $\Phi(D_0) = 0,\Phi(D_i) >= 0\quad \forall i,\lceil log(i) \rceil$<=log(i)+1

| 0    | 0    | 0    | 0    | 0    | 0    |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

$\Phi = 2*6-2^2=4$

Counting : 0 0 0 0 2 2

Amortizations  Cost of i -th insert

$\hat{c_i} = c_i + \Phi(D_i)-\Phi(D_{i-1})\\ =i\quad if \  i-1 \ is\ power\  of\ 2,\\ \quad1\quad otherwise\\ + (2i-2^{\lceil log(i) \rceil})-( 2(i-1)-2^{\lceil log(i-1) \rceil})\\ =i\quad if \  i-1 \ is\ power\  of\ 2,\\  \quad1\quad otherwise\\ +2-2^{\lceil log(i) \rceil}+2^{\lceil log(i-1) \rceil}$



Case 1, i -1 is exact power of 2

$\hat{c_i} = i +2-2(i-1)+(i-1)\\ =3$

Case 2,i -1 is not an exact power of 2

$\hat{c_i} = 1 +2\\ =3$ 

=>n inserts costs $\Theta(n)$ in the worst case

(bug：第一个其实是2)

$\hat{c_i}=1+2-1+0\\ =2$

## sum

- 平摊分析为数据结构的性能提供了一个简洁的抽象概念。

- 通常情况下每种都能用，每种都有某种情况是最简单或精确的。

- 不同的势能函数或不能的记账代价可能产生不同的上限

# 竞争性分析、自组织表

### Self-organizing lists

List L of n elems 

- Operation Access(x),costs  rank(x) = distace of x from head of L

- L can be reorder by transposing adjcent elements ,cost = 1

Ex

L - > (12) ->(3)->(50)->(14)->(17)->(4)

------------50----3

------------trans-------cost = 4

------------cost 1------for access

### Define Online:

A sequence S of operations is provided one at a time for each operation ,for each op an online algorithm must execute the operation immediately

### Off-line 

may see all of S in advance

###  Goal min total cost $C_A(S)$

### Worst Case analysis

Always access tail elems of L

$C_A(S)=\Omega(|S|n)$   Worst case 

### Average case analysis

suppose elem x is accessed with prob P(x)

$E[C_A(S)]=\sum_{x}P(x)*rank(x)$

Which is minimized when L sorted in decreasing order with respect to P

Heuristic(启发)：Keep account of #times each elem is accessed and maintain lis in order of decreassing count



Practice: "Move - to front" Heuristic

After accessing x move x to head of list,using transposes Cost = 2*rank(x). (Access ,transposes)



Respons well is locality in S

## Competitive analysis

### Def. $\alpha$-competitive

 An on-line is $\alpha$-competitive

if $\exists$const k for any Seq S of ops

$C_A(S)<=\alpha*C_{OPT}(S)+k$ (Opt is the optimal off-line algorithm,"God's alg")



### Theorem: MTF is 4-competitive for self-org     (Move to front)

Proof:

Let$L_i$ be MTF's list after i-th access
    '$L_i^*$' OPT's
    
Let $C_i$ = MTF cost for i-th op
          = 2*rank($L_{i-1}(x)$) if it access x
     $C_i^{ *}$ = OPT's cost for i-th op
             = $ rank_{ L_{i-1}} (x)+t_i$. if opt forms $t_i$ transposes 
    
Ddefine potential function $\phi$ {$L_i$}->R by

$\Phi(L_i)$=2*|{x,y}  , $x\prec_{L_i}y$   and  $y\prec_{L_i^ * }x$  }|(集合的势就是集合的元素有多少) $\prec$ 代表优先

​			 = 2#inversions

Ex: 

$L_i$ -> (E) ->(C)->(A)->(D)->(B)

$L_i^ *$ ->(C)->(A)->(B)->(D)->(E)

$\Phi(L_i)$ = 2*|{(E,C),(E,A),(E,D),(E,B),(B,D)}|=10

NOTE:

$\Phi(L_i)$ >=0$\forall$

$\Phi(L_0)$=0 if MTF and OPT start with same list

How much does  $\Phi$ change from 1 tranposes

transposes creates or destroy one inversion  

$\Delta\Phi = \pm2$

What happens when op i access x ? 

Define:

 A = {$y\in L{i-1},y \prec _{L_{i-1}}x \ and\ y \prec _{L_{i-1}^ *} x$}

 B = {$y\in L{i-1},y \prec _{L_{i-1}}x \ and\ y \succ _{L_{i-1}^ *}$x}

 C = {$y\in L{i-1},y \succ _{L_{i-1}}x \ and\ y \prec _{L_{i-1}^ *}x$}

 D = {$y\in L{i-1},y \succ _{L_{i-1}}x \ and\ y \succ _{L_{i-1}^ *}x$}

$L_{i-1}$

<---------------------------

|------A$\cup$ B----------------|x|------C$\cup$ D--------|

​												r = $rank_{L_{i-1}}(x)$

$L_{i-1}^ * $ 

|----A$\cup$ C---x|---------------------- B$\cup$ D------|

​					$r^ * $= $rank_{L_{i-1}^{ * }}(x)$

we have 

r = |A|  +  |B| + 1

$r^*$ = |A| + |C| + 1



When MTF moves x to front ,it creates |A| inverstions and destroy |B| inversinos

Each transpose by OPT create <=   1    inversion ($t_i$ times)

Thus

$\Phi(L_i)-\Phi(L_{i-1})<=2(|A|-|B|+t_i)$

## Amortized cost

$\hat{c_i}=c_i+\Phi(L_i)-\Phi(L_{i-1}) \\ <= 2*r + 2(|A|-|B|+t_i)\\ = 2*r+2(|A|-(r-1-|A|)+t_i) \quad since \ r = |A|+|B| + 1 \\ =2*r+4*|A|-2*r+2+3*t_i \\ = 4|A|+2+2t_i\\ <=4*(r^* + t_i) \quad since \ r^* = |A|+|C|+1 >=|A|+1 \\ = c_i^ *$

Thus $C_MTF(S) = \sum_{i=1} c_i \\ = \sum_{i=1}\hat{c_i}+\Phi(L_i)-\Phi(L_{i-1}) \\ = \sum_{i=1}4_i c^*+\Phi(L_0)-\Phi(L_S)(=0,>0)\\ <= 4 C_{OPT}(S)$



If we count transpose that move x to front of L as "free"

modeles splicing(拆分) x in and out of L in constant time and MTF is 2-competitve



What if $L_0\neq L_0^* $ Then. $\Phi(L_0)$ Might be  $\Theta(n^2)$C(n-1,2)

Thus

 $C_MTF(S)<= 4 C_{OPT}(S)+\Theta(n^2)$

is still 4 - comp.    since $n^2$ is constant as the size of S goes to infinity.     |S|->∞ 

