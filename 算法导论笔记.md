#  平摊分析、表的扩增、势能方法

## hash表需要多大？

越大越好(time)

尽可能小(space )

$\Theta $(n) for n items

Problem  :don't know n?

## Solution: dynamic tables

overflow => grow it

- 1.Reallocate  (molloc ot new) 2*n ,double it

- 2.move to new

- 3.free old table

Analytics 

Seq of insert ops 

Worst cost of 1 insert $\Theta$(n)

=>Worst cost of n inserts  = n* $\Theta$(n)=$\Theta$($n^{2}$)

Wrong :Worst cost of n inserts  = $\Theta$(n)

Let $c_i $ = i if i- is exaotct power of 2 ,  = 1 otherwise

i.        1. 2. 3  4 5 6 7. 8 9 10

size.  1. 2. 4. 4 8 8 8 8 16 16



c_i.    1. 2. 3. 1 5 1 1 1   9   1

​     1  1  1  1 1 1 1 1.  1.  1

​               1 2.     4             8

 = $\sum _{i = 1}^{n} =n + \sum_{j = 0}^{log(n-1)}2^{j}\\<=3n=\Theta(n)$

Thus ,average cost of n insert  = $\Theta (n)/n=\Theta(1)$

## Amortized analysis

Analyze a seq of ops to shwo that ave cost per op is small, even though 1 op may be expensive 

no probability - ave perf in worst case

Types of amortized arguments 

- Aggregate (just -saw) 聚集分析

- Accounting  记账方法.         }
-  potential 势能分析              }.     更精确，为每个操作分配了特定的平摊代价(不能轻松分析时)

### Accounting method

- Charage i -th op a 虚构的平摊代价 cost $\hat{c_i}$ ($1 pays for 1unit of work)

- 费用是支付给每个操作的，

- 剩余的钱将会存放在银行里，为了后续的操作

- bank balance not go neg，Must have $\sum c_i <= \sum\hat{c_i}$ ,真实代价小于等于平摊代价

Dynamic table 

Charge $\hat{c_i}$ = $3 for i-th insert

$1 for an immediate insert

$2 ,用于将表翻倍的存储费用

 When table double

$1 moves recent item

$1 moves old item

| 0    | 0    | 0    | 0    |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

再插入一个剩下$2

| 0    | 0    | 0    | 0    | 2    |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

再插入一个剩下$2

| 0    | 0    | 0    | 0    | 2    | 2    |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

再插入一个..

| 0    | 0    | 0    | 0    | 2    | 2    | 2    | 2    |
| ---- | ---- | ---- | :--- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

加倍后，正好$8

| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 2    |      |      |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

| 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 2    | 2    | 2    |      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |      |

这样总是够，银行总不负

所以$\hat{c_i}$ 平摊代价

$\sum c_i <= \sum \hat{c_i}$ 

​			<= 3n

i.-----1-2-3--4-5-6-7--8--9---10

size--1-2-4--4-8-8-8--8--16---16

c_i---1-2-3--1-5-1-1--1---9----1

------1-1-1--1-1-1-1--1- -1- ---1

------1-2------4------8

$\hat{c_i}$  --- 2  3. 3 3  3. 3 3 3.  3. 3

Bnk.  1 2  2  4 2. 4 6 8.  2   4

第一个可以收3，也可以

并且尝试全是2，不够

删除时要注意反复

### Potential  method

"Bank account " viewed as potential 

energy of dynamic set



### Framework

- Start with data struct $D_0$

- Op i transforms $D_{i-1} => D_{i}$

- Cost of operate $c_i$

=>Define potential function

找到函数$\Phi  - \{ D_i \}->R$ 将数据结构映射到实数

$\Phi(D_0) = 0\quad and\quad \Phi(D_i) >=0\quad  \forall i$

(可能D_0不等于0，这只是一种)

定义平摊代价 $\hat{c_i}$   for $\Phi $  is

$\hat{c_i} = c_i + \Phi(D_i)-\Phi(D_{i-1})$

​				potential difference,$ \Delta \Phi_i$	

If $ \Delta \Phi_i > 0$ then $\hat{c_i}$ > c_i

stores work in data structure for later

说明收取的费用多余实际费用，多余的费用存进银行变为势能	

If $ \Delta \Phi_i < 0$ then $\hat{c_i} $> c_i

Structure delivers up work to help pay for op i

### Total amor cost of n ops is

$\sum_{i=1}^{n}\hat{c_i} = \sum_{i=1}^{n}( c_i + \Phi(D_i)-\Phi(D_{i-1}))\\ =\sum_{i=1}^{n}c_i+\Phi(D_n)-\Phi(D_0)\\ >=\sum_{i=1}^{n}c_i$

For  $\Phi(D_n)>=0,\Phi(D_0) = 0$

### Table doubling

Define $\Phi(D_i) = 2i-2^{\lceil log(i) \rceil}$ 

Assume    $2^{\lceil log(0) \rceil} = 0$

Note: $\Phi(D_0) = 0,\Phi(D_i) >= 0\quad \forall i,\lceil log(i) \rceil$<=log(i)+1

| 0    | 0    | 0    | 0    | 0    | 0    |      |      |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
|      |      |      |      |      |      |      |      |

$\Phi = 2*6-2^2=4$

Counting : 0 0 0 0 2 2

Amortizations  Cost of i -th insert

$\hat{c_i} = c_i + \Phi(D_i)-\Phi(D_{i-1})\\ =i\quad if \  i-1 \ is\ power\  of\ 2,\\ \quad1\quad otherwise\\ + (2i-2^{\lceil log(i) \rceil})-( 2(i-1)-2^{\lceil log(i-1) \rceil})\\ =i\quad if \  i-1 \ is\ power\  of\ 2,\\  \quad1\quad otherwise\\ +2-2^{\lceil log(i) \rceil}+2^{\lceil log(i-1) \rceil}$



Case 1, i -1 is exact power of 2

$\hat{c_i} = i +2-2(i-1)+(i-1)\\ =3$

Case 2,i -1 is not an exact power of 2

$\hat{c_i} = 1 +2\\ =3$ 

=>n inserts costs $\Theta(n)$ in the worst case

(bug：第一个其实是2)

$\hat{c_i}=1+2-1+0\\ =2$

## sum

- 平摊分析为数据结构的性能提供了一个简洁的抽象概念。

- 通常情况下每种都能用，每种都有某种情况是最简单或精确的。

- 不同的势能函数或不能的记账代价可能产生不同的上限

# 竞争性分析、自组织表

### Self-organizing lists

List L of n elems 

- Operation Access(x),costs  rank(x) = distace of x from head of L

- L can be reorder by transposing adjcent elements ,cost = 1

Ex

L - > (12) ->(3)->(50)->(14)->(17)->(4)

------------50----3

------------trans-------cost = 4

------------cost 1------for access

### Define Online:

A sequence S of operations is provided one at a time for each operation ,for each op an online algorithm must execute the operation immediately

### Off-line 

may see all of S in advance

###  Goal min total cost $C_A(S)$

### Worst Case analysis

Always access tail elems of L

$C_A(S)=\Omega(|S|n)$   Worst case 

### Average case analysis

suppose elem x is accessed with prob P(x)

$E[C_A(S)]=\sum_{x}P(x)*rank(x)$

Which is minimized when L sorted in decreasing order with respect to P

Heuristic(启发)：Keep account of #times each elem is accessed and maintain lis in order of decreassing count



Practice: "Move - to front" Heuristic

After accessing x move x to head of list,using transposes Cost = 2*rank(x). (Access ,transposes)



Respons well is locality in S

## Competitive analysis

### Def. $\alpha$-competitive

 An on-line is $\alpha$-competitive

if $\exists$const k for any Seq S of ops

$C_A(S)<=\alpha*C_{OPT}(S)+k$ (Opt is the optimal off-line algorithm,"God's alg")



### Theorem: MTF is 4-competitive for self-org     (Move to front)

Proof:

Let$L_i$ be MTF's list after i-th access
    '$L_i^*$' OPT's
    
Let $C_i$ = MTF cost for i-th op
          = 2*rank($L_{i-1}(x)$) if it access x
     $C_i^{ *}$ = OPT's cost for i-th op
             = $ rank_{ L_{i-1}} (x)+t_i$. if opt forms $t_i$ transposes 
    
Ddefine potential function $\phi$ {$L_i$}->R by

$\Phi(L_i)$=2*|{x,y}  , $x\prec_{L_i}y$   and  $y\prec_{L_i^ * }x$  }|(集合的势就是集合的元素有多少) $\prec$ 代表优先

​			 = 2#inversions

Ex: 

$L_i$ -> (E) ->(C)->(A)->(D)->(B)

$L_i^ *$ ->(C)->(A)->(B)->(D)->(E)

$\Phi(L_i)$ = 2*|{(E,C),(E,A),(E,D),(E,B),(B,D)}|=10

NOTE:

$\Phi(L_i)$ >=0$\forall$

$\Phi(L_0)$=0 if MTF and OPT start with same list

How much does  $\Phi$ change from 1 tranposes

transposes creates or destroy one inversion  

$\Delta\Phi = \pm2$

What happens when op i access x ? 

Define:

 A = {$y\in L{i-1},y \prec _{L_{i-1}}x \ and\ y \prec _{L_{i-1}^ *} x$}

 B = {$y\in L{i-1},y \prec _{L_{i-1}}x \ and\ y \succ _{L_{i-1}^ *}$x}

 C = {$y\in L{i-1},y \succ _{L_{i-1}}x \ and\ y \prec _{L_{i-1}^ *}x$}

 D = {$y\in L{i-1},y \succ _{L_{i-1}}x \ and\ y \succ _{L_{i-1}^ *}x$}

$L_{i-1}$

<---------------------------

|------A$\cup$ B----------------|x|------C$\cup$ D--------|

​												r = $rank_{L_{i-1}}(x)$

$L_{i-1}^ * $ 

|----A$\cup$ C---x|---------------------- B$\cup$ D-------|

​					$r^ * $= $rank_{L_{i-1}^{ * }}(x)$

we have 

r = |A|  +  |B| + 1

$r^*$ = |A| + |C| + 1



When MTF moves x to front ,it creates |A| inverstions and destroy |B| inversinos

Each transpose by OPT create <=   1    inversion ($t_i$ times)

Thus

$\Phi(L_i)-\Phi(L_{i-1})<=2(|A|-|B|+t_i)$

## Amortized cost

$\hat{c_i}=c_i+\Phi(L_i)-\Phi(L_{i-1}) \\ <= 2*r + 2(|A|-|B|+t_i)\\ = 2*r+2(|A|-(r-1-|A|)+t_i) \quad since \ r = |A|+|B| + 1 \\ =2*r+4*|A|-2*r+2+3*t_i \\ = 4|A|+2+2t_i\\ <=4*(r^* + t_i) \quad since \ r^* = |A|+|C|+1 >=|A|+1 \\ = c_i^ *$

Thus $C_MTF(S) = \sum_{i=1} c_i \\ = \sum_{i=1}\hat{c_i}+\Phi(L_i)-\Phi(L_{i-1}) \\ = \sum_{i=1}4_i c^*+\Phi(L_0)-\Phi(L_S)(=0,>0)\\ <= 4 C_{OPT}(S)$



If we count transpose that move x to front of L as "free"

modeles splicing(拆分) x in and out of L in constant time and MTF is 2-competitve



What if $L_0\neq L_0^* $ Then. $\Phi(L_0)$ Might be  $\Theta(n^2)$C(n-1,2)

Thus

 $C_MTF(S)<= 4 C_{OPT}(S)+\Theta(n^2)$

is still 4 - comp.    since $n^2$ is constant as the size of S goes to infinity.     |S|->∞ 





# Bellman、差分约束系统

## Bellman-Ford

Computers shorteset 

Path weight $\delta(S,V)$

 from source vertex S$\in$ V

to all vertice v$\in$V



OR: 

reports that a negative

Weight cycle exists



EXecise :

Computer  $\delta(S,V)$ even when some are $-\infin$ 



Bellman-ford 

d[s] <- 0

for each v$\in$ V - {s}.        ---init

​		d(s) = 0 d[v] <-$\infin$     

For i <- to |V|-1

​	do for each edge (u,v) $\in$E

​		do if d[v] > d[u] + w(u,v)

​				then d[v] <- d[u] + w(u,v)

for each  edge (u,v) $\in$E

​	do if d[v] > d[u] + w(u,v)

​			then report that a negative weight cycle exits

​	else

d[v] = $\delta(S,V)$

O(VE) 





Correctness :

if G(V,E) has no neg - weight cycle  then ,bellman-ford terminates with d[v] = $\delta(S,V)$ for all v$\in$V

Consider any v$\in$V

Monotonicity (单调性) o f d values correctness I

d[v] >= $\delta(S,V)$  Only need to show  some point we have equal

that d[v] = $\delta(S,V)$ 

Let $p = v_0->v_1->...->v_k$

be a shortes path for s to V

With minimum number of edges

=>p is a simple path (防止0权环)

$\delta(S,V_i)=\delta(S,V_{i-1})+w(V_{i-1},V_i)$ （最优子结构

d[$v_0$] = 0 (init)=$\delta(S,V_0)$



Assume by induction that d[$V_j$] = $\delta(S,V_j)$ after j rounds for j < i

After i -1 rounds d[$V_{i-1}$]=$\delta(S,V_{i-1})$

during round  relax ($V_{i-1},V_i$)

正确性引理

=>d[$V_j$] = $\delta(S,V_j)$

After k rounds d[V] = $\delta(S,V)$   k <=|V| -1. （因为是简单图



 Corollary(必然的): if Bellman-ford fails to converge after |V| -1 rounds then must be a neg-weight cycles



## Linear Programming(LP)

Given  mxn. matrix A ,

m - vector b.   n -vectors c,

find  n -vector x that maximizes  $C^Tx(=CX)$

subject to Ax <= b

Or determine no such X



Many efficient Algorithms  to solve LPS

- simplex   <----exp in worst case
- Ellpsoid   <----polynomial time(不实用)
- Interior point 
- Random sample



## Linear feasibility problems

no objective c ,find x s.t.  Ax<=b

Act not easily than LP

Difference constraints 

Linear feasibility  problems

When each row of matrix A

Has one 1  one -1, rest 0's

each contrstrint is of form  $x_j - x_i <= w_{ij}$

Example 

$x_1-x_2<=3 \\ x_2-x_3 <=-2 \\ x_1-x_3 <= 2$

Sol: x1=3,x2=0,x3=2



## Constraint graph

 $x_j - x_i <= w_{ij}$   => (V_i) ---w_ij----->(V_j) 

｜V｜ = n ,|E| =m

图：

(V2)---3---->(V1)

(V3)---(-2)-->(V2)

(V3)---2---->(V1)

$x_j <= x_i +w_{ij} \\ d[i]<=d[j]+w_{ij}$

### Theorem

if  constraint graph

Has neg-weight cycle

Then difference constraints are unsatisifiable

Proof: Let$v_1->v_2->...->v_k->v_i$

Is a neg-weight cycles

$x_2-x_{1} <= w{12}$}

$x_3-x_{2} <= w{23}$  }------------------->no

$x_k-x_{k-1} <= w{k-1,k}$}

$x_1-x_k<=w_{k,1}$}

累加后:

0 <= w(cycle ) < 0

### Theorem

If no neg-weigth cycles in constraint graph  G then difference constraint are satisfiable 

Proof:

Add to G a new vertex S with a weight -0  edge from s to all v $\in$ V

(V2)---3---->(V1)

(V3)---(-2)-->(V2)

(V3)---2---->(V1)

S-----0---->v1

S-----0---->v2

S-----0---->v3

Modified no neg-weight cycles

&  has path from S

=>has shortest path from S

assign $x_i=\delta(S,V_{i})$

$x_j-x_i<=wij \quad<=>\quad \delta(S,j)-\delta(S,i)<=w(V_i,V_j) \\ \delta(S,j)<=\delta(S,i)+w(V_i,V_j)$

$(V_i,V_j)\in E$

和Bellman-Ford等价

Corollary(必然的): 

Bellman-Ford solve a system of m difference on n variable in O(mn) time



Exercise:

Bellman-ford also maximizes $x_1+x_2+...+x_n$ 

Subject to $x_i <=0 ,x_j-x_i<=wij$

Exercise: also minizieds  $max (x_i)-min(x_i)$

## VLSI - layout

Prolem place IC, features without putting any two features too close

x2-x1 >= d + eps

Bellman - Ford solve these constraints and minimized the spread max x_i - min xi

=> maximized compactness