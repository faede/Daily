C++98(1.0)

C++03(TR!,technical Report 1)

C++11(2.0)

C++14

## Variadic Templates

```cpp
void printX()
{
    
}
template<typename T,typename.. Types>
void printX(const T& firstArg, const Types &... args)
{
    cout<<firstArg <<endl;
    printX(args...);
}

void print()
{
    
}
template<typename T,typename... Types>
void print(const T& firstArg, const Types &... args)
{
    cout<<firstArg <<endl;
    print(args...);
}


//sizeof...(args)获取个数
//只能在可变参数模板中使用

```





以STL课程中的万用hash为例子



```cpp
template<typename...Values> class tuple;
template<>class tuple<>{};
template<typename Head,typename ... Tail>
class tuple<Head,Tail...>:private tuple<Tail...>//recursive inheritance
{
    
    ...
    protected:
    Head m_head;
}

```

## Spaces in Template Expressions

```cpp
vector<list<int> >;//Ok in each C++version
vector<list<int>>;//Ok since C++11
```

## nullptr and std::nullptr_t


C++11 lets you use nullptr  instead of 0 or NULL;

```cpp
void f(int);
void f(void *);
f(0);//calls f(int)
f(NULL);//calls ambiguous otherwise
f(nullptr)//calls f(void *)
```

nullptr is new keyword

It has type  std::nullptr_t

```cpp
typedef decltype(nullptr) nullptr_t;
```

## Automatic Type Deduction with auto

主要是用在比较复杂/长的type上

```cpp
auto l = [](int x)->bool{ // l has the type of a lambda
    ...,
};
```



```cpp
#if __cplusplus >= 201103L
inline auto operator-(const reverse_iterator<>
```



##  Unifrom Initialization

